'''
Ex1
Считать из файла input1.txt 10 чисел (числа записаны через пробел).
Затем записать их произведение в файл output.txt.
'''

from functools import reduce

f = open('index1.txt')
r = f.read()
lst = [float(i) for i in r.split()]
f.close()
m = str(reduce(lambda x, y: x*y, lst))
f_1 = open('output.txt', 'w')
f_1.write(m)
f_1.close()


'''
Ex2
В файле input2.txt записаны целые числа. Найти максимальное и минимальное число и записать в другой файл.
'''

f_2 = open('index2.txt')
r_2 = f_2.read()
lst_2 = [float(i) for i in r_2.split()]
f_2.close()
f_3 = open('output_1.txt', 'a')
f_3.write(str(min(lst_2))+'\n')
f_3.write(str(max(lst_2)))
f_3.close()


'''
Ex3
В файл input3.txt записаны сведения о сотрудниках некоторой фирмы в виде:
Иванов 45 бухгалтер
Необходимо записать в текстовый файл сведения о сотрудниках, возраст которых меньше 40.
'''

f_4 = open('index3.txt')
f_5 = open('output_2.txt', 'a')
r_3 = f_4.readline()
lst_3 = []
for r_3 in f_4:
    if int(r_3.split()[1]) < 40:
       f_5.write(r_3)
f_4.close()
f_5.close()
            
  
'''
Ex4
В файле input4.txt записаны в столбик целые числа.
Отсортировать их по возрастанию суммы цифр и записать в другой файл.
'''

f_6 = open('index4.txt')
f_7 = open('output_3.txt', 'a')
r_4 = f_6.read()
lst_4 = sorted(r_4.split())
for i in lst_4:
    f_7.write(i + '\n')
f_6.close()
f_7.close()


'''
Ex5
Вводится буква. Определить, это код английской буквы или какой-либо иной символ.
'''

n = str(input())
s = ord(n)
a = ord('a')
z = ord('z')
A = ord('A')
Z = ord('Z')
if a <= s <= z or A <= s <= Z:
    print('Это буква')
else:
    print('Это не буква')
   

'''
Ex6
Дано натуральное число n. Выведите все числа от 1 до n. (использовать рекурсию)
'''

def num(n):
    if n == 1:
        return 1
    print(n)
    return num(n-1)


'''
Ex7
Дано натуральное число N. Выведите все его цифры по одной, в обратном порядке, разделяя их пробелами или новыми строками.
Разрешена только рекурсия и целочисленная арифметика.
Пример:
179

9 7 1
'''


'''
Ex8
Написать функцию, которая принимает произвольное количество позиционных и ключевых аргументов.
Функция возвращает произведение всех ключевых и позиционных аргументов, являющихся целыми числами,
объединение в одну строку всех ключевых и позиционных аргументов, являющихся строками,
в качестве разделителя использовать '_'.

Пример
foo(1, 2, 2.0, 'str', 6, a='key', b=12, c=3.56, d='world', e=-11, f='2') == 10, 'str_key_world_2'
'''

def foo(*args, **kwargs):
    strs = []
    nums = []
    for i in args:
        if type(i) == int:
            nums.append(i)
        elif type(i) == str:
            strs.append(i)
    for k, v in kwargs.items():
        if type(v) == int:
            nums.append(v)
        elif type(v) == str:
            strs.append(v)
    strs1 = '_'.join(strs)        
    nums1 = reduce(lambda x, y: x*y, nums)
    return strs1, nums1


'''
Ex9
Написать функцию, которая принимает на вход 2 списка lst1, lst2, содержащих только целые числа,
и возвращает список, элементами которого будут lst1[i]**lst2[i]

Пример:
foo([-2, 2, 4], [3, 0, 2] == [-8, 1, 16]
foo([1, 2, 3], [4, 5]) == [1, 32]
'''

def mult(lst1, lst2):
    lst3 = []
    for i in range(min(len(lst2), len(lst1))):
        lst3.append(lst1[i]**lst2[i])
    return lst3    

'''
Ex10
Напишите декоратор с параметрами bucket, который будет делать так,
что задекорированная функция, прежде чем возвращать результат,
будет распечатывать в стандартный поток вывода все переданные bucket аргументы в следующем формате:

аргументы распечатаны в виде пары (кортежа размера два)
первый элемент пары --  кортеж со значениями переданных bucket аргументов без имени
(значения в этом кортеже следуют в том же порядке, в котором соответствующие аргументы были переданы bucket)
второй элемент пары -- словарь с элементами вида имя: значение для всех переданных bucket именованных аргументов.

Пример:
@bucket(1, 2, 3, [1, 2, 3], 'one', 'two', 'three', one = 1, two = 2, three = 3)
def identity(x):
  return x


print(identity(42))
>>> ((1, 2, 3, [1, 2, 3], 'one', 'two', 'three'), {'two': 2, 'one': 1, 'three': 3})
42

@bucket()
def identity(x):
  return x


print(identity(42))
>>> ((), {})
42
'''
